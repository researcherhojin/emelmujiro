// 임시 블로그 데이터 (나중에 API 연결 가능)
export const blogPosts = [
  {
    id: 1,
    title: "AI와 머신러닝의 미래",
    slug: "ai-and-machine-learning-future",
    excerpt: "인공지능이 우리의 일상을 어떻게 변화시키고 있는지 알아봅니다.",
    content: `## AI 기술의 현재와 미래

인공지능(AI)과 머신러닝 기술은 이제 우리 일상의 일부가 되었습니다. 스마트폰의 음성 비서부터 자율주행 자동차까지, AI는 빠르게 발전하며 우리의 삶을 변화시키고 있습니다.

### 주요 발전 분야
- **자연어 처리**: ChatGPT, Claude 등 대화형 AI의 등장
- **컴퓨터 비전**: 의료 진단, 보안 시스템에서의 활용
- **추천 시스템**: 개인화된 콘텐츠 추천
- **자동화**: 업무 프로세스 자동화와 효율성 향상

### 미래 전망
앞으로 AI는 더욱 정교해지고 인간과 자연스럽게 협업하는 시대가 올 것입니다. 윤리적인 AI 개발과 규제가 중요한 과제가 될 것입니다.`,
    author: "이호진",
    date: "2024-01-15",
    created_at: "2024-01-15T09:00:00Z",
    updated_at: "2024-01-15T09:00:00Z",
    published: true,
    category: "AI",
    tags: ["인공지능", "머신러닝", "딥러닝", "ChatGPT"],
    image_url: "https://images.unsplash.com/photo-1677442136019-21780ecad995?w=400&h=300&fit=crop"
  },
  {
    id: 2,
    title: "효과적인 프로그래밍 학습법",
    slug: "effective-programming-learning",
    excerpt: "초보자를 위한 프로그래밍 학습 가이드",
    content: `## 프로그래밍 학습의 정석

프로그래밍을 처음 시작하는 분들이 가장 많이 하는 질문은 "어떻게 시작해야 하나요?"입니다.

### 1. 언어 선택
- **Python**: 초보자에게 가장 추천하는 언어
- **JavaScript**: 웹 개발을 목표로 한다면 필수
- **Java/C++**: 컴퓨터 과학 기초를 탄탄히 하고 싶다면

### 2. 학습 방법
1. **기초 문법 익히기**: 변수, 조건문, 반복문
2. **작은 프로젝트 만들기**: 계산기, Todo 리스트
3. **코드 읽기**: 오픈소스 프로젝트 분석
4. **꾸준한 연습**: 매일 조금씩이라도 코딩하기

### 3. 추천 리소스
- Codecademy, freeCodeCamp
- 백준, 프로그래머스 (알고리즘 연습)
- GitHub (포트폴리오 관리)`,
    author: "이호진",
    date: "2024-01-10",
    created_at: "2024-01-10T09:00:00Z",
    updated_at: "2024-01-10T09:00:00Z",
    published: true,
    category: "교육",
    tags: ["프로그래밍", "코딩", "학습법", "초보자"],
    image_url: "https://images.unsplash.com/photo-1516321318423-f06f85e504b3?w=400&h=300&fit=crop"
  },
  {
    id: 3,
    title: "웹 개발 트렌드 2024",
    slug: "web-development-trends-2024",
    excerpt: "올해 주목해야 할 웹 개발 기술들",
    content: `## 2024년 웹 개발 트렌드

웹 개발 분야는 매년 새로운 기술과 트렌드가 등장합니다. 2024년에 주목해야 할 트렌드를 소개합니다.

### 1. AI 통합 개발
- GitHub Copilot, Cursor 등 AI 도구 활용
- AI 기반 코드 생성 및 디버깅

### 2. 서버리스 아키텍처
- Vercel, Netlify 등 플랫폼 활용
- 인프라 관리 부담 감소

### 3. WebAssembly
- 브라우저에서 네이티브급 성능
- Rust, Go 등 다양한 언어 지원

### 4. 프레임워크 동향
- **React**: 여전히 강세, Server Components 주목
- **Vue 3**: Composition API 성숙
- **Svelte/SvelteKit**: 빠른 성장세`,
    author: "이호진",
    date: "2024-01-05",
    created_at: "2024-01-05T09:00:00Z",
    updated_at: "2024-01-05T09:00:00Z",
    published: true,
    category: "웹개발",
    tags: ["웹개발", "프론트엔드", "React", "트렌드"],
    image_url: "https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=400&h=300&fit=crop"
  },
  {
    id: 4,
    title: "React vs Vue vs Angular: 2024년 비교",
    slug: "react-vue-angular-comparison-2024",
    excerpt: "주요 프론트엔드 프레임워크 비교 분석",
    content: `## 프론트엔드 프레임워크 선택 가이드

### React
- **장점**: 큰 생태계, 풍부한 라이브러리
- **단점**: 학습 곡선, 많은 선택지
- **적합한 경우**: 대규모 프로젝트, 유연성 필요

### Vue
- **장점**: 쉬운 학습, 뛰어난 문서
- **단점**: 상대적으로 작은 생태계
- **적합한 경우**: 중소규모 프로젝트, 빠른 개발

### Angular
- **장점**: 완전한 프레임워크, TypeScript 기본
- **단점**: 복잡성, 큰 번들 크기
- **적합한 경우**: 엔터프라이즈 앱, 대규모 팀`,
    author: "이호진",
    date: "2024-01-20",
    created_at: "2024-01-20T09:00:00Z",
    updated_at: "2024-01-20T09:00:00Z",
    published: true,
    category: "프론트엔드",
    tags: ["React", "Vue", "Angular", "프레임워크"],
    image_url: "https://images.unsplash.com/photo-1633356122544-f134324a6cee?w=400&h=300&fit=crop"
  },
  {
    id: 5,
    title: "클라우드 네이티브 애플리케이션 개발",
    slug: "cloud-native-application-development",
    excerpt: "쿠버네티스와 도커를 활용한 현대적인 앱 개발",
    content: `## 클라우드 네이티브란?

클라우드 네이티브는 클라우드 환경에 최적화된 애플리케이션 개발 방식입니다.

### 핵심 기술
1. **컨테이너화 (Docker)**
   - 애플리케이션 패키징
   - 환경 일관성 보장

2. **오케스트레이션 (Kubernetes)**
   - 컨테이너 관리 자동화
   - 스케일링과 로드 밸런싱

3. **마이크로서비스**
   - 서비스 독립성
   - 개별 배포 가능

### 장점
- 확장성과 유연성
- 빠른 배포 사이클
- 장애 격리`,
    author: "이호진",
    date: "2024-01-18",
    created_at: "2024-01-18T09:00:00Z",
    updated_at: "2024-01-18T09:00:00Z",
    published: true,
    category: "DevOps",
    tags: ["클라우드", "쿠버네티스", "도커", "마이크로서비스"],
    image_url: "https://images.unsplash.com/photo-1667372393119-3d4c48d07fc9?w=400&h=300&fit=crop"
  },
  {
    id: 6,
    title: "TypeScript 완벽 가이드",
    slug: "typescript-complete-guide",
    excerpt: "JavaScript 개발자를 위한 TypeScript 입문",
    content: `## TypeScript를 배워야 하는 이유

TypeScript는 JavaScript의 슈퍼셋으로, 정적 타입을 제공합니다.

### 주요 특징
- **타입 안정성**: 컴파일 시점 오류 검출
- **IDE 지원**: 자동완성, 리팩토링
- **최신 JavaScript 기능**: ES6+ 지원

### 기본 문법
\`\`\`typescript
interface User {
  id: number;
  name: string;
  email?: string;
}

function greetUser(user: User): string {
  return \`Hello, \${user.name}!\`;
}
\`\`\`

### 학습 로드맵
1. 기본 타입 이해
2. 인터페이스와 타입 별칭
3. 제네릭
4. 고급 타입`,
    author: "이호진",
    date: "2024-01-12",
    created_at: "2024-01-12T09:00:00Z",
    updated_at: "2024-01-12T09:00:00Z",
    published: true,
    category: "프로그래밍",
    tags: ["TypeScript", "JavaScript", "타입스크립트"],
    image_url: "https://images.unsplash.com/photo-1619410283995-43d9134e7656?w=400&h=300&fit=crop"
  }
];

export const getBlogPosts = () => {
  try {
    // Get custom posts from localStorage
    const customPostsData = localStorage.getItem('customBlogPosts');
    const customPosts = customPostsData ? JSON.parse(customPostsData) : [];
    
    // Merge with default posts (custom posts first for visibility)
    const allPosts = [...customPosts, ...blogPosts];
    
    // Remove duplicates based on ID
    const uniquePosts = allPosts.filter((post, index, self) =>
      index === self.findIndex((p) => p.id === post.id)
    );
    
    // Sort by date (newest first) - properly handle date comparison
    uniquePosts.sort((a, b) => {
      const dateA = new Date(b.created_at).getTime();
      const dateB = new Date(a.created_at).getTime();
      return dateA - dateB;
    });
    
    return Promise.resolve(uniquePosts);
  } catch (error) {
    console.error('Error loading blog posts:', error);
    return Promise.resolve(blogPosts);
  }
};

export const getBlogPost = (id) => {
  try {
    // First check custom posts
    const customPostsData = localStorage.getItem('customBlogPosts');
    const customPosts = customPostsData ? JSON.parse(customPostsData) : [];
    const customPost = customPosts.find(p => p.id === parseInt(id));
    
    if (customPost) {
      return Promise.resolve(customPost);
    }
    
    // Then check default posts
    const post = blogPosts.find(p => p.id === parseInt(id));
    return Promise.resolve(post);
  } catch (error) {
    console.error('Error loading blog post:', error);
    // Fallback to default posts
    const post = blogPosts.find(p => p.id === parseInt(id));
    return Promise.resolve(post);
  }
};